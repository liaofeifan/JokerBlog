<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        <meta name="author" content="wangzhizhou">
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Use GDB - Joker's Blog</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome-4.5.0.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../../css/highlight.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->
	
	<script src="../../js/jquery-1.10.2.min.js"></script>
        <script src="../../js/bootstrap-3.0.3.min.js"></script>
        <script src="../../js/highlight.pack.js"></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../..">Joker's Blog</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                    <li >
                        <a href="../..">About Me</a>
                    </li>
                    <li >
                        <a href="../../How I create this blog/">Create your own blog as me</a>
                    </li>
                    <li class="dropdown active">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Z-turn <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../Network Simulator 2 Installation Guide for Ubuntu/">Network Simulator 2 Installation Guide for Ubuntu</a>
</li>
                            
<li >
    <a href="../Learn STL In 30 Minutes/">Learn STL In 30 Minutes</a>
</li>
                            
<li >
    <a href="../Installation of Ubuntu 16.04 On UDisk/">Installation of Ubuntu 16.04 On UDisk</a>
</li>
                            
<li >
    <a href="../Configure Git Server With Ubuntn and Apache 2/">Configure Git Server With Ubuntn and Apache 2</a>
</li>
                            
<li >
    <a href="../Add Watermark on Video with OpenCV and FFmpeg/">Add Watermark on Video with OpenCV and FFmpeg</a>
</li>
                            
<li >
    <a href="../Develop DLNA Using Platinum Library/">Develop DLNA Using Platinum Library</a>
</li>
                            
<li >
    <a href="../FFmpeg and SDL tutorial 1/">FFmpeg and SDL tutorial 1</a>
</li>
                            
<li >
    <a href="../FFmpeg compiled on MacOS/">FFmpeg compiled on MacOS</a>
</li>
                            
<li >
    <a href="../FFmpeg version 3.1.4 example code/">FFmpeg version 3.1.4 example code</a>
</li>
                            
<li >
    <a href="../Fmpeg 2.8.6 example code - transcoding/">Fmpeg 2.8.6 example code   transcoding</a>
</li>
                            
<li >
    <a href="../Nmap Basics/">Nmap Basics</a>
</li>
                            
<li class="active">
    <a href="./">Use GDB</a>
</li>
                            
<li >
    <a href="../User OpenCV to add watermark on a video/">User OpenCV to add watermark on a video</a>
</li>
                            
<li >
    <a href="../Wireshark Basics/">Wireshark Basics</a>
</li>
                            
<li >
    <a href="../Optimizing App Startup Time/">Optimizing App Startup Time</a>
</li>
                            
<li >
    <a href="../OpenVPN on Raspberry Pi/">OpenVPN on Raspberry Pi</a>
</li>
                            
<li >
    <a href="../swift on client and server/">Swift on client and server</a>
</li>
                            
<li >
    <a href="../my hardware/">My hardware</a>
</li>
                            
<li >
    <a href="../kotlin/">Kotlin</a>
</li>
                            
<li >
    <a href="../Convert MP4 to GIF With FFmpeg/">Convert MP4 to GIF With FFmpeg</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">etc <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../life/alipay-scan-fu-icon/">Alipay scan fu icon</a>
</li>
                            
<li >
    <a href="../../life/Renting in Beijing/">Renting in Beijing</a>
</li>
                            
<li >
    <a href="../../life/Gu Bei Shui Zhen/">Gu Bei Shui Zhen</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Music <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../music/whistle/">Whistle</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Game <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../minecraft/minecraft/">Minecraft</a>
</li>
                        </ul>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle" data-toggle="dropdown">Me <b class="caret"></b></a>
                        <ul class="dropdown-menu">
                            
<li >
    <a href="../../me/English Personal Resume/">English Personal Resume</a>
</li>
                            
<li >
    <a href="../../me/My Plan for finding Job/">My Plan for finding Job</a>
</li>
                            
<li >
    <a href="../../me/Personal Pre-Work Record/">Personal Pre Work Record</a>
</li>
                            
<li >
    <a href="../../me/My Financial Planning/">My Financial Planning</a>
</li>
                            
<li >
    <a href="../../me/Life in Beijing/">Life in Beijing</a>
</li>
                            
<li >
    <a href="../../me/jokerhub/">Jokerhub</a>
</li>
                        </ul>
                    </li>
                </ul>

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                    <li >
                        <a rel="next" href="../Nmap Basics/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li >
                        <a rel="prev" href="../User OpenCV to add watermark on a video/">
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                    <li>
                        <a href="https://github.com/wangzhizhou/JokerBlog">
                                <i class="fa fa-github"></i>GitHub
                        </a>
                    </li>
            </ul>
        </div>
    </div>
</div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#use-gdb">Use GDB</a></li>
        <li class="main "><a href="#_1">一个调试实例</a></li>
        <li class="main "><a href="#debug-1-">Debug #1 - 程序死循环</a></li>
        <li class="main "><a href="#debug-2-">Debug #2 - 程序逻辑错误</a></li>
        <li class="main "><a href="#debug-3-">Debug #3 - 程序段错误</a></li>
        <li class="main "><a href="#debug-4-">Debug #4 - 程序遗漏情况</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="use-gdb">Use GDB</h1>
<p>用了几天GDB，觉得挺好用的，特别是写示例程序的时候，由于源文件也不是很复杂，调试工作还是使用轻量级的GDB来的方便、直接，同时GDB还可以远程调试，功能上也是很强大的。</p>
<p>下面整理一下使用GDB调试过程中经常使用的一些命令和组合键：</p>
<ul>
<li><code>gdb insert_sort</code> 使用GDB调试程序<code>insert_sort</code></li>
<li><code>break 16</code>    在程序的第16行设置断点</li>
<li><code>tbreak 16</code> 在程序第16行设置一个临时断点，中止一次后失效</li>
<li><code>clear 16</code>    清除程序第16行设置的断点</li>
<li><code>delete 1</code>    删除第一个断点</li>
<li><code>disable 1 2 5</code> 使断点1，2，5不起作用</li>
<li><code>enable  1 2 5</code> 使断点1，2，5起作用 </li>
<li><code>enable once 1 2</code> 使能断点1，2起作用一次，之后disable</li>
<li><code>info break</code>  查看所有断点信息</li>
<li><code>ctrl-P</code>和<code>ctrl-N</code> 前后浏览代码或编辑</li>
<li><code>ENTER</code>   重复执行上次调试命令</li>
<li><code>next</code>    调试下一句代码(Step Over)</li>
<li><code>next 3</code> 向下走三句(Step Over)</li>
<li><code>define</code>  可以定义相关的宏命令，使输入命令更加自由和个性</li>
<li><code>run 12 5 6</code> 运行到断点12、5、6时暂停执行</li>
<li><code>list</code>    多个源文件调试时显示不同的代码区域</li>
<li><code>step</code>    步入调试（Step Into)</li>
<li><code>continue</code> 继续执行</li>
<li><code>continue 3</code> 继续执行，并忽略三次断点</li>
<li><code>commands 3</code>给断点关联相关的命令，一行一条命令，以end结束，添加一条slient命令可以屏掉断点停止时自动产生的相关信息输出</li>
<li><code>define</code> 定义GDB宏命令，以end结束定义, 参数以$号开始</li>
<li><code>show user</code> 列出所有用户自定义的宏命令</li>
<li><code>until</code> 继续执行，直到一个循环完成</li>
<li><code>until swap</code> 继续执行，直到swap函数被执行</li>
<li><code>finish</code> 继续执行，直到函数返回</li>
<li><code>tbreak 16</code> 16行设置临时断点，临时断点只会进入一次</li>
<li><code>until</code>和<code>finish</code>用来创建条件断点</li>
<li><code>watch i</code> 观察变量i,只要它的值发生了改变，就会停止运行</li>
<li><code>print j</code> 程序到断点暂停时，打印变量值</li>
<li><code>watch z</code> 变量z的值改变时，暂停执行程序</li>
<li><code>watch (z&gt;28)</code> 设置条件判断的监视断点</li>
<li><code>frame 1</code> 查看前一个调用栈信息</li>
<li><code>frame 0</code> 查看当前调用栈</li>
<li><code>up</code>  调用栈上一级</li>
<li><code>down</code>    调用栈下一级</li>
<li><code>backtrace</code>       查看整个调用栈信息</li>
<li><code>help</code>        查看GDB帮助信息</li>
</ul>
<p>GDB还提供了<code>TUI</code>模式，可以在命令行中提供<code>GUI</code>类似的显示。</p>
<ul>
<li><code>gdb -tui insert_sort</code>    以TUI模式启动GDB</li>
<li><code>ctrl-X-A</code>    命令行时<code>非TUI</code>和<code>TUI</code>模式相互转换</li>
</ul>
<p>知道了一些基本命令，就以一个实际调试例子巩固一下。</p>
<h1 id="_1">一个调试实例</h1>
<p>下面一个示例程序<code>insert_sort.c</code>，使用以下命令编译：</p>
<pre><code>gcc -g -Wall -o insert_sort insert_sort.c
</code></pre>

<p>编译后生成了二进制执行文件:<code>insert_sort</code>，这里必须使用<code>-g</code>参数告诉编译器保存符号表(代码行号和变量内存地址相关的列表)，如果没有这个符号表，就不能在调试的时候使用诸如：<code>在30行中断</code>和<code>打印变量x的值</code>这类的操作。</p>
<p>现在的编译器也是很智能的，一般在编译阶段也能检查出一些错误来，就像下面这样：</p>
<pre><code>insert_sort.c:29:10: warning: using the result of an assignment as a condition without parentheses
      [-Wparentheses]
        if(num_y=0)
           ~~~~~^~
insert_sort.c:29:10: note: place parentheses around the assignment to silence this warning
        if(num_y=0)
                ^
           (      )
insert_sort.c:29:10: note: use '==' to turn this assignment into an equality comparison
        if(num_y=0)
                ^
                ==
1 warning generated.
</code></pre>

<p>下面是有问题的程序源代码：</p>
<pre><code class="cpp">
/* filename: insert_sort.c */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int x[10],y[10],num_inputs,num_y=0;

void print_results()
{
    int i;
    for(i=0;i&lt;num_inputs;i++)
    {
        printf(&quot;%d\n&quot;,y[i]);
    }
}

void scoot_over(int jj)
{
    int k ;
    for(k=num_y-1;k&gt;jj;k++)
    {
        y[k]=y[k-1];
    }
}

void insert(int new_y)
{
    int j;
    if(num_y=0)
    {
        y[0]=new_y;
        return ;
    }

    for(j=0;j&lt;num_y;j++)
    {
        if(new_y &lt; y[j])
        {
            scoot_over(j);
            y[j]=new_y;
            return;
        }
    }
}

void process_data()
{
    for(num_y=0;num_y&lt;num_inputs;num_y++)
    {
        insert(x[num_y]);
    }
}

void get_args(int ac, char **av)
{
    int i;
    num_inputs = ac - 1;    
    for(i=0; i&lt;num_inputs; i++)
    {
        x[i] = atoi(av[i+1]);
    }
}

int main(int argc, char **argv)
{
    get_args(argc,argv);
    process_data();
    print_results();
    return 0;
}
</code></pre>

<p>我们先运行一下：</p>
<pre><code>./insert_sort 12 5
</code></pre>

<p>发现程序陷入了死循环。使用Ctrl-C中断程序运行。这是第一个需要解决的bug。</p>
<h1 id="debug-1-">Debug #1 - 程序死循环</h1>
<p>使用GDB TUI模式进行调试(可以使用<code>ctrl-X-A</code>在命令行和TUI模式间相互转换)：</p>
<pre><code>gdb insert_sort -tui
</code></pre>

<p>按<code>Enter</code>进入GDB TUI调试环境后，使用带有参数<code>12 5</code>的运行(run)命令启动程序，会发现程序一直运行，并进入死循环</p>
<pre><code>run 12 5
</code></pre>

<p>这时我们使用命令<code>Ctrl+C</code>来中止调试程序的运行(此时并不会退出GDB调试环境，由于暂停时程序运行的位置不确定，所以你试验时的情况和我稍有些不同，不过不会影响),我们发现程序停留在函数<code>process_data()</code>中的for循环中，些时<code>num_y=1</code>，我们使用了GDB的<code>print</code>命令来查看变量值。初步断定死循环发生的位置后，就要进一步寻找出现的原因，进而Debug</p>
<pre><code>   ┌──ins.c────────────────────────────────────────────────────────────────────┐
   │43              }                                                          │
   │44      }                                                                  │
   │45                                                                         │
   │46      void process_data()                                                │
   │47      {                                                                  │
  &gt;│48              for(num_y=0;num_y&lt;num_inputs;num_y++)                      │
   │49              {                                                          │
   │50                      insert(x[num_y]);                                  │
   │51              }                                                          │
   │52      }                                                                  │
   │53                                                                         │
   │54      void get_args(int ac, char **av)                                   │
   │55      {                                                                  │
   └───────────────────────────────────────────────────────────────────────────┘
native process 18485 In: process_data                        L48   PC: 0x400684 
Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...
Reading symbols from insert_sort...done.
(gdb) run 12 5
Starting program: /home/parallels/Documents/debug/insert_sort 12 5
^C
Program received signal SIGINT, Interrupt.
0x0000000000400684 in process_data () at ins.c:48
(gdb) print num_y
$1 = 0 
</code></pre>

<p>我们使用<code>next</code>命令单步调试，<code>next</code>命令不会进入函数内部，这是一种先粗后细的调试方式，单步调试了几次，发现每次执行完<code>insert(x[num_y]);</code>这一句后，<code>num_y</code>都会变成<code>0</code>，从而导致<code>for</code>循环不能结束。由是我们使用<code>step</code>命令在调试到<code>insert(x[num_y]);</code>时，进入函数内部调试，由于<code>num_y</code>是个全局变量，在<code>insert</code>函数内部第一行时错误的把<code>==</code>用成了<code>=</code>赋值，导致第次函数执行完后，<code>num_y</code>都被置为了0</p>
<pre><code>   ┌──ins.c────────────────────────────────────────────────────────────────────┐
   │24      }                                                                  │
   │25                                                                         │
   │26      void insert(int new_y)                                             │
   │27      {                                                                  │
   │28              int j;                                                     │
  &gt;│29              if(num_y=0)                                                │
   │30              {                                                          │
   │31                      y[0]=new_y;                                        │
   │32                      return ;                                           │
   │33              }                                                          │
   │34                                                                         │
   │35              for(j=0;j&lt;num_y;j++)                                       │
   │36              {                                                          │
   └───────────────────────────────────────────────────────────────────────────┘
native process 18485 In: insert                              L29   PC: 0x4005f0 
(gdb) next
(gdb) step
insert (new_y=5) at ins.c:29
(gdb) 
</code></pre>

<p>发现原因后， 我们另开一个控制台修改源码并重新编译，为的是不退出当前的GDB调试环境，可以保留调试中设置过的断点等信息，这里我们还没有设置过断点。</p>
<p>在另一个控制台中重新编译并运行后，发现死循环解除了，但是排序结果不正确：</p>
<pre><code>parallels@ubuntu:~/Documents/debug$ gcc -g -Wall -o insert_sort ins.c
parallels@ubuntu:~/Documents/debug$ ./insert_sort 12 5
5
0
</code></pre>

<h1 id="debug-2-">Debug #2 - 程序逻辑错误</h1>
<p>我们发现<code>12</code>没有被正确的插入到第二个位置，于是我们回到GDB调试环境所在的控制台，在<code>insert</code>函数中设置断点后，使用<code>run</code>命令重新开始一次调试，<code>run</code>默认为使用上一次使用的参数<code>12 5</code></p>
<pre><code>   ┌──ins.c────────────────────────────────────────────────────────────────────┐
   │24      }                                                                  │
   │25                                                                         │
   │26      void insert(int new_y)                                             │
   │27      {                                                                  │
   │28              int j;                                                     │
B+&gt;│29              if(num_y==0)                                               │
   │30              {                                                          │
   │31                      y[0]=new_y;                                        │
   │32                      return ;                                           │
   │33              }                                                          │
   │34                                                                         │
   │35              for(j=0;j&lt;num_y;j++)                                       │
   │36              {                                                          │
   └───────────────────────────────────────────────────────────────────────────┘
native process 25009 In: insert                              L29   PC: 0x4005f0 
[Inferior 1 (process 24275) exited normally]
(gdb) break insert
Breakpoint 1 at 0x4005f0: insert. (4 locations)
(gdb) run
Starting program: /home/parallels/Documents/debug/insert_sort 12 5

Breakpoint 1, insert (new_y=12) at ins.c:29
(gdb) 

(gdb) 
</code></pre>

<p>我们看到程序在断点处停止运行了，再次使用单步调试整个数组的插入过程，对于第一个数字<code>12</code>,第一次会被插入排序结果数组的第一个位置，第二个数字<code>5</code>在被插入时会先与当前排序结果数组的每个元素进行比较，如果比较小，会把排序结果数组的每一个数据向后移动一个位置，为这个较小的数据腾出一个位置来放入。</p>
<pre><code>   ┌──ins.c────────────────────────────────────────────────────────────────────┐
   │33              }                                                          │
   │34                                                                         │
   │35              for(j=0;j&lt;num_y;j++)                                       │
   │36              {                                                          │
   │37                      if(new_y &lt; y[j])                                   │
   │38                      {                                                  │
   │39                              scoot_over(j);                             │
   │40                              y[j]=new_y;                                │
  &gt;│41                              return;                                    │
   │42                      }                                                  │
   │43              }                                                          │
   │44      }                                                                  │
   │45                                                                         │
   └───────────────────────────────────────────────────────────────────────────┘
native process 25009 In: insert                              L41   PC: 0x400638 
(gdb) print y
$5 = {12, 0, 0, 0, 0, 0, 0, 0, 0, 0}
(gdb) n
(gdb) print y
$6 = {5, 0, 0, 0, 0, 0, 0, 0, 0, 0}
(gdb)  
</code></pre>

<p>在这个插入排序的过程中，发现在数字<code>5</code>被插入后，之前的数字<code>12</code>没有被正确的后移一位，所以问题就定位 在函数<code>scoot_over</code>中了，因为它的功能和我们期望的不一致。我们再设置断点到<code>scoot_over</code>函数中，并清除之前的断点，因为问题是出现在数字<code>5</code>与数字<code>12</code>比较后的<code>scoot_over</code>调用时，所以我们可以把断点设置为条件断点，也就是<code>num_y</code>为<code>1</code>时：</p>
<pre><code>   ┌──ins.c────────────────────────────────────────────────────────────────────┐
   │15      }                                                                  │
   │16                                                                         │
   │17      void scoot_over(int jj)                                            │
   │18      {                                                                  │
   │19              int k ;                                                    │
B+&gt;│20              for(k=num_y-1;k&gt;jj;k++)                                    │
   │21              {                                                          │
   │22                      y[k]=y[k-1];                                       │
   │23              }                                                          │
   │24      }                                                                  │
   │25                                                                         │
   │26      void insert(int new_y)                                             │
   │27      {                                                                  │
   └───────────────────────────────────────────────────────────────────────────┘
native process 28018 In: scoot_over                          L20   PC: 0x4005ad 

(gdb) clear 29
Deleted breakpoint 1
(gdb) break scoot_over if num_y==1
Breakpoint 2 at 0x4005ad: file ins.c, line 20.
(gdb) i b
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x00000000004005ad in scoot_over at ins.c:20
        stop only if num_y==1
(gdb) c   
Continuing.

Breakpoint 2, scoot_over (jj=0) at ins.c:20
(gdb) p num_y
$7 = 1
</code></pre>

<p>这时我们运行到断点处停止下来，使用单步调试，发现<code>scoot_over</code>函数中的for循环一次都没有执行。此时<code>num_y</code>为1，所以<code>k</code>为0，而<code>jj</code>也是0，所以没有进入循环中，所以<code>k</code>的初始值赋值不正确，应该修改为<code>k=num_y</code></p>
<p>再次在另一个控制台修改源程序，编译运行，发现产生了段错误，这是由于内存地址访问不当引起的：</p>
<pre><code>parallels@ubuntu:~/Documents/debug$ gcc -g -Wall -o insert_sort ins.c
parallels@ubuntu:~/Documents/debug$ ./insert_sort 12 5
Segmentation fault (core dumped)
</code></pre>

<h1 id="debug-3-">Debug #3 - 程序段错误</h1>
<p>这时就体现出开两个控制台的好处了，回到GDB环境后，清除之前的断点，并再次运行, GDB会在段错误的位置停下来：</p>
<pre><code>   ┌──ins.c────────────────────────────────────────────────────────────────────┐
   │17      void scoot_over(int jj)                                            │
   │18      {                                                                  │
   │19              int k ;                                                    │
   │20              for(k=num_y;k&gt;jj;k++)                                      │
   │21              {                                                          │
  &gt;│22                      y[k]=y[k-1];                                       │
   │23              }                                                          │
   │24      }                                                                  │
   │25                                                                         │
   │26      void insert(int new_y)                                             │
   │27      {                                                                  │
   │28              int j;                                                     │
   │29              if(num_y==0)                                               │
   └───────────────────────────────────────────────────────────────────────────┘
native process 30018 In: scoot_over                          L22   PC: 0x4005cc 

(gdb) clear 20
Deleted breakpoint 2
(gdb) run
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/parallels/Documents/debug/insert_sort 12 5

Program received signal SIGSEGV, Segmentation fault.
0x00000000004005cc in scoot_over (jj=0) at ins.c:22
(gdb) print k
$8 = 976
</code></pre>

<p>此时我们将数组索引值打印出来，发现它远远大于排序结果数组的边界<code>10</code>, 这是由于for循环的变量k自加引起的错误，我们将其修改为自减。再次编译运行：</p>
<pre><code>parallels@ubuntu:~/Documents/debug$ gcc -g -Wall -o insert_sort ins.c
parallels@ubuntu:~/Documents/debug$ ./insert_sort 12 5
5
12
</code></pre>

<p>发现排序两个数字正确了，我们试着排下多个数据。</p>
<pre><code>parallels@ubuntu:~/Documents/debug$ ./insert_sort 12 5 19 22 6 1
1
5
6
12
0
0
</code></pre>

<h1 id="debug-4-">Debug #4 - 程序遗漏情况</h1>
<p>发现排序结果对于数字<code>19 22</code>有问题，我们重新调试插入数据19和22时的过程，设置断点，并单步跟踪，发现，它们大于排序结果中的所有数据时，需要被插入到最后的位置，但事实上程序没有考虑到这种情况。</p>
<pre><code>   ┌──ins.c────────────────────────────────────────────────────────────────────┐
   │29              if(num_y==0)                                               │
   │30              {                                                          │
   │31                      y[0]=new_y;                                        │
   │32                      return ;                                           │
   │33              }                                                          │
   │34                                                                         │
  &gt;│35              for(j=0;j&lt;num_y;j++)                                       │
   │36              {                                                          │
B+ │37                      if(new_y &lt; y[j])                                   │
   │38                      {                                                  │
   │39                              scoot_over(j);                             │
   │40                              y[j]=new_y;                                │
   │41                              return;                                    │
   │42                      }                                                  │
   │43              }                                                          │
   │44      }                                                                  │
   │45                                                                         │
   │46      void process_data()                                                │
   │47      {                                                                  │
   └───────────────────────────────────────────────────────────────────────────┘
native process 32621 In: insert                              L35   PC: 0x400637 
(gdb) break 37 if new_y == 19
Breakpoint 1 at 0x40060b: file ins.c, line 37.
(gdb) run 12 5 19 22 6 1
Starting program: /home/parallels/Documents/debug/insert_sort 12 5 19 22 6 1

Breakpoint 1, insert (new_y=19) at ins.c:37
(gdb) print y  
$1 = {5, 12, 0, 0, 0, 0, 0, 0, 0, 0}
(gdb) n
(gdb) 
</code></pre>

<p>所以我们需要在第<code>43</code>行后面补充这种情况：<code>y[j]=new_y;</code></p>
<p>重新编译并运行：</p>
<pre><code>parallels@ubuntu:~/Documents/debug$ gcc -g -Wall -o insert_sort ins.c
parallels@ubuntu:~/Documents/debug$ ./insert_sort 12 5 19 22 6 1
1
5
6
12
19
22
</code></pre>

<p>这次发现结果正确，但还需要进一步的测试一下。整个过整就是这个样子，调试是一门艺术而不是科学，通常很难描述这整个过程，所以有疏漏的地方，请多包涵。</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
                <p>created by wangzhizhou</p>
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>var base_url = '../..';</script>
        <script data-main="../../mkdocs/js/search.js" src="../../mkdocs/js/require.js"></script>
        <script src="../../js/base.js"></script><div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
